# SOLID原則
## 単一責任の原則（SRP：Single Responsibility Principle）
```
モジュールを変更する理由はたったひとつだけであるべきである。
```
ここでのモジュールとは、いくつかの関数やデータをまとめた凝集性のあるもの、例えばクラスである。

モジュールが複数の役割を背負っているような場合、それらの役割は結合してしまう。その結果、ある役割が変更を受けると、そのモジュールが担っている他の役割も影響を受け、不具合が生じる恐れがある。結果、ある部分が変更を受けると、予想もしない形で壊れてしまうような脆い設計になる。

## オープン・クローズドの原則（OCP：Open-Closed Principle）
```
ソフトウェアの構成要素は拡張に対しては開いていて、修正に対して閉じていなければならない。
```
言い換えると、「ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できようにするべきである」ということ。

1. 拡張に対して開かれている（Open）
モジュールの振る舞いを拡張できるという意味。アプリケーションの使用要求が変更されても、モジュールに新たな振る舞いを追加することでその変更に対処できる。
    
2. 修正に対して閉じている（Closed）
モジュールの振る舞いを拡張しても、そのモジュールのソースコードやバイナリコードは全く影響を受けない。

## リスコフの置換原則（LSP：Liskov Substitution Principle）
```
派生型はその基本形と置換可能でなければならない。
```

## インターフェイス分離の原則（ISP：Interface Segregation Principle）
```
クライアントに、クライアントが利用しないメソッドへの依存を強制してはならない。
```
インターフェイスに用意されている利用しないプロパティやメソッドに依存してしまうと、クライアント（インターフェースの利用者）はそういったメソッドの変更の影響を受けやすくなる。
そういった不本意な結び付きをできるだけ避けるために、インターフェースはできるだけ分離しておくべきというものである。


## 依存関係逆転の原則（DIP：Dependency Inversion Principle）
```
上位のモジュールは下位のモジュールに依存してはならない。どちらのモジュールも「抽象」に依存すべきである。

「抽象」は実装の詳細に依存してはならない。実装の詳細が「抽象」に依存すべきである。
```
アプリケーションの方針に基づく重要な判断やビジネスモデルを含み、アプリケーションの存在理由を決定づけているのは上位のモジュールである。それにもかかわらず、上位モジュールが下位モジュールに依存すると、下位モジュールの変更が直接上位モジュールに影響を与え、上位モジュールまで変更を余儀なくされることになる。

ビジネスルールを担当する上位レベルのモジュールは、実装の詳細を担当している下位のモジュール
とは独立し、立場も上になるべきである。

# 単一責任の原則と、単純にファイルを細かなファイルに分解することの違い
同じ理由で変化する（変更理由が似ている）ものを集めるのが単一責任の原則である。そして、その変化を引き起こすのはアクター（システムとやり取りする外部の人や物）である。



# リスコフの置換原則（LSP）に違反した場合、どのような不都合が生じるか？
LSPに違反している例を以下に示す。
```cpp
struct Point {double x,y;};
struct Shape {
  enum ShapeType {square, circle} itsType;
  Shape(ShapeType t) : itsType(t) {}
};

struct Circle : public Shape
{
  Circle() : Shape(circle) {};
  void Draw() const;
  Point itsCenter;
  double itsRadius;
};

struct Square : public Shape
{
  Square() : Shape(square) {};
  void Draw() const;
  Point itsTopLeft;
  double itsSide;
};

void DrawShape(const Shape& s)
{
  if (s.itsType == Shape::square)
    static_cast<const Square&>(s).Draw();
  else if (s.itsType == Shape::circle)
    static_cast<const Circle&>(s).Draw();
};
```
DrawShape関数は、Shapeクラスのあらゆる派生形を知っていなければならないので、新たにShapeクラスの派生型が作られたら変更を余儀なくされる。そのため、OCPに違反している。

LSPに違反しているのは、SquareとCircleがShapeの代わりとして使えないという点。そのせいでDrawShapeはOCPに違反する。

**LSPに違反すれば、必然的にOCPにも違反してしまう。**


# インターフェースを用いる事で、設計上どのようなメリットがあるか？
- 同じインターフェースを実装する複数のクラスに、共通のメソッド群を実装するように強制できる
- あるクラスがインターフェースを実装していれば、少なくともそのインターフェースが定めたメソッドを持っていることが保証される

# どんな時に依存性の逆転を用いる必要が生じるか？
依存関係逆転の原則（DIP）を絶対のものとして守り続けるのは現実的ではない。
例えば、JavaのStringクラスは具象であり、ソースコードが具象のjava.lang.stringに依存するのは避けられないし、避けるべきでもない。
Stringクラスは、あらゆる局面で利用されるクラスであるため、危険な拡張を防止するためにfinal修飾子による継承の禁止が宣言されている。また、インスタンス化の後に内容が変化しないimmutableな設計となっている。そのようなこともあり、Stringクラスの内容がコロコロ変わることを心配する必要はない。

このような理由から、DIPを考えるときには**OSやプラットフォーム周りは気にしないことが多い**。変化しないとみなして構わないので、こうした具象への依存は許容することにする。
依存したくないのは、システム内の変化しやすい具象要素で、開発中のモジュールや頻繁に変更され続けているモジュールがその対象になる。
