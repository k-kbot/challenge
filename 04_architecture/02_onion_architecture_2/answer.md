# 課題 1

## オニオンアーキテクチャの図解

下図のように、依存関係は「外側の層から内側の層」のみ許可する。

![](./images/onion_architecture_circle.jpg)

### ドメイン層（ドメインモデル層 + ドメインサービス層）

ドメイン知識（ルール/制約）を表現する。この層を独立させ、他の層への依存を持たせないようにする。

主なクラスは、ドメインオブジェクト（エンティティ、値オブジェクト、ドメインイベント）と、それを利用するクラス（リポジトリのインターフェース、ドメインサービス、ファクトリー）がある。

### ユースケース層（アプリケーション層）

ドメイン層が公開している操作を組み合わせて、ユースケースを実現させる。特定のクライアントには依存しない実装にする。

主なクラスは、ユースケースクラス、プレゼンテーション層との入出力を定義するクラスがある。

### プレゼンテーション層

アプリケーション外部との入出力を実現する。JSON でレスポンスを返したり、HTML をレンダリングして返すのはこの層の責務。

主なクラスは、コントローラ、アプリケーション外部との入出力を定義するクラスがある。

### インフラストラクチャ層（インフラ層）

下位のレイヤーで定義されているインターフェースを実装し、アプリケーションを支える技術的な機能を提供する。

主なクラスは、リポジトリの実装クラスがある。

## ドメイン層が他のどの層にも依存しないメリット

エヴァンス本で紹介されているレイヤードアーキテクチャでは、ドメイン層はインフラ層に依存している。そのため、インフラ層の OR マッパーや、RDBMS や NoSQL などのデータストアを切り替える場合に、その影響範囲がドメイン層まで及ぶことになる。

一方で、ドメイン層が他のどの層にも依存しないオニオンアーキテクチャでは、ドメイン層の修正はドメインモデルに変更があったときのみで済む。

## 層をまたいで依存関係が発生する時、インターフェースに対する依存のみ許可するメリット

データベースアクセスを担当するクラス（データソースクラス）と、そのクラスを使ってユーザを登録するサービスを提供するクラス（サービスクラス）を考える。

### サービスクラスがデータソースクラスに依存する場合

```typescript
// 利用する側のサービスクラス
class UserService {
  datasource: UserDatasource; // ここでデータソースクラスに依存することを宣言

  constructor(datasource: UserDatasource) {
    this.datasource = datasource;
  }

  register(user: User): void {
    this.datasource.register(user);
  }
}

// 利用される側のデータソースクラス
// 利用する側のUserServiceクラスとは無関係に独立している
class UserDatasource {
  register(user: User): void {
    // データベースに登録
  }
}
```

- UserService クラスは UserDatasource クラスに依存している。
  - UserService クラスの datasource フィールドで UserDatasource クラスのインスタンスを使うことを宣言している。
  - UserService クラスは、UserDatasource クラスが定義済みでないとコンパイルできない。
- UserDatasource クラスは独立している。
  - UserDatasource クラスには、UserService クラスに関する記述はない。

### インターフェースを使う場合

```typescript
// インターフェース
interface IUserRepository {
  register(user: User): void;
}

// サービスクラスはインターフェースに依存する
class UserService {
  repository: IUserRepository; // 依存先をインターフェースにする

  constructor(repository: IUserRepository) {
    this.repository = repository;
  }

  register(user: User): void {
    this.repository.register(user);
  }
}

// データソースクラスはインターフェースを実装する
class UserDatasource implements IUserRepository {
  register(user: User): void {
    // データベースに登録
  }
}
```

- UserService クラスの依存先は、UserDatasource クラスから IUserRepository インターフェースに変える。
- UserDatasource クラスは IUserRepository インターフェースを実装し、インターフェースに依存するようにする。

インターフェースを使うと、依存の方向を変えることができる。
サービスクラスは提供すべき機能の定義で、プログラムを作る目的を表現する。それに対しデータソースクラスは機能を実現する手段である。

このように、依存の方向を逆転することで、目的を表現したクラスに手段を実現するクラスが依存するようになる。目的の定義が先で手段の記述が後になる。この依存関係の逆転は、目的にあったソフトウェアを開発するための良いアプローチとなる。

参考: [Software Design 2021 年 3 月号](https://gihyo.jp/magazine/SD/archive/2021/202103)

## オニオンアーキテクチャでは「依存性の逆転」がどのように使われているか

### レイヤードアーキテクチャ

上の層から下の層に依存することのみを許可する。

![](./images/layered_architecture.jpg)

そのため、ユースケース層やドメイン層がインフラ層に依存し、ソフトウェアの主導権をインフラ層が握ることになってしまう（ソフトウェアにおいて重要なのはユースケース層やドメイン層）。

また、最下位のインフラ層（≒ データストア）には他のどの層からもアクセスすることができてしまう。本来はドメイン層に記述されるべき重要なルールが、プレゼンテーション層やユースケース層にも分散してしまい、修正が様々な箇所に及ぶようになる（スマート UI というアンチパターン）。

### オニオンアーキテクチャ

前述のインターフェースを利用して、レイヤードアーキテクチャのユースケース層・ドメイン層とインフラ層の依存関係を逆転させたのがオニオンアーキテクチャである。

![](./images/onion_architecture_flat.jpg)

ドメイン層は何にも依存しなくなることで、ドメインモデルを中心とした設計が可能になる。

## 特定のユーザにしかリソースの追加や更新を許さないようなアクセス制限機能はどの層に記述するべきか

ドメイン層に「リソースの追加や更新権限を持つユーザ」を表すインターフェイスを定義して、それを引数に使用する。
この「リソースの追加や更新権限を持つユーザ」は「ユーザ」クラスとは別物として定義し、ユーザ ID や、保持するロールなどの必要な最低限の項目のみ返すようにする。リソース作成・更新のメソッドにこれを渡して、ロールで判断する。

「リソースの追加や更新権限を持つユーザ」の実装クラスは認証の仕組みと同様にプレゼンテーション層に記述する。
ドメイン層、ユースケース層は認証にどのような仕組みを使用するかの知識を持たず、この「リソースの追加や更新権限を持つユーザ」を受け取って操作(認証された)ユーザのユーザ ID などを受け取る。そしてプレゼンテーション層で認証の仕組みを実装する。

参考: [ddd-q-and-a#220](https://github.com/little-hands/ddd-q-and-a/issues/220)

## RDB を MySQL から PostgreSQL に変更する場合、どの層を変更するべきか

下図は、アプリケーションとその外側に境界があり、その間はアダプターを通じて通信することを示している。

![](./images/onion_architecture_adapter.jpg)

インフラ層のデータストアのアダプター（リポジトリの実装クラス）を変更することで、RDB の交換が可能である。

# 課題 2

オニオンアーキテクチャでトランザクション処理はどのように管理すればよいか？（ドメイン駆動設計 サンプルコード&FAQ より）

<details><summary>回答</summary>ユースケースクラスのメソッド入り口でトランザクションを開始し、メソッドが正常終了したらコミット、例外が発生したらロールバック、とする。</details>
