# 課題１（質問）

## インデックスの仕組み

インデックスとは、電話帳や辞書の索引のように、あるルールに従って並べられたデータ構造のこと。
テーブルの指定した列の値と行の位置情報が紐づけられている。

インデックスを使わない検索の場合、SQL で指定された表の全てのデータにアクセスして、検索条件を満たす行を 1 行ずつチェックするため時間がかかる（フルテーブルスキャン）。

一方で、インデックスを使った検索では、まずインデックスにアクセスして検索条件に該当する行がテーブルのどこにあるのかを割り出す。その後、この情報を元にテーブルにアクセスすることで、効率的に検索することができる。

## なぜ slow query log を調べるべきか

slow query log は MySQL で出力できるログの一種で、実行時間が指定した時間より長いクエリを記録することができる。

闇雲にインデックスを作成すると、更新系のクエリではかえってパフォーマンスが落ちることもあるため、スロークエリを改善するためのインデックス設計をするべきである。

## カーディナリティとは

特定の列の値がどのぐらいの種類の多さを持つか、ということを表す概念のこと。
例えば「性別」を表す列で、男・女・不詳という値を持つとすると、この列のカーディナリティは 3 になる。

B-tree インデックスを作るときは、カーディナリティの高い列を選ぶことが基本となる。

## カバリングインデックスとは

クエリを処理するために必要なデータを全て含んでいるインデックスのこと。

インデックスだけで検索が完結し、テーブルアクセスがないためパフォーマンス改善の効果が高い。

ただし、カバリングインデックスはインデックス自体に必要な情報を含めるため、インデックスのサイズが大きくなることや、インデックスの更新コストが増えるという一面もある。

## auto increment の id カラムを PK とすること

### メリット

- データの並びに規則があるので、インデックスを利用しやすい。
- id のユニーク制約違反が発生しない。

### デメリット

- ユーザからレコード数が想定されやすい。
- 存在する id が類推しやすくスクレイピングが容易であるため、サーバに負荷がかかりやすい。
- DB に INSERT するまで id の値が決まらないため、アプリケーションでレコードに対応するオブジェクトを生成する際に、id がない不完全なオブジェクトになる。

参考: [id を autoincrement して何が悪いの？](https://zenn.dev/praha/articles/3c84e3818891c3)

# 課題 2（実装）

# 課題 3（実装）

# 課題 4（質問）

## 複合インデックスの仕組み

複合インデックスとは、複数のカラムを組み合わせたインデックスのこと。

カラムの組み合わせの順番が重要で、カーディナリティが高いカラムを先にした方が効果を得やすい。
ただし、たとえカーディナリティが高くても特定の値にデータが集中しているようなカラムは向いていない。

単一のカラムを対象としたインデックスに比べて更新コストが大きいため、注意が必要である。

## 複合インデックスの順番

複合インデックスでは、最初に指定した列でソート、次にそのソートの中で 2 つ目に指定した列でソート...というデータの並びになる。

そのため、最初の列に first_name（名）を指定した複合インデックスでは、last_name（姓）だけの検索の場合に速度向上の恩恵を受けることができない。

姓だけの検索が多いのであれば、以下のように複合インデックスの最初の列に last_name を指定するのがよい。

```diff
- CREATE INDEX employees_name ON employees (first_name, last_name)
+ CREATE INDEX employees_name ON employees (last_name, first_name)
```
